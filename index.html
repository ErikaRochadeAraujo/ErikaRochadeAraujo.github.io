<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador de Resson√¢ncia Magn√©tica - IA</title>
    
    <!-- Bibliotecas necess√°rias -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://unpkg.com/nifti-reader-js@0.6.8/release/nifti-reader.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .upload-btn-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .status-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .status-text {
            font-size: 1.1em;
            font-weight: 500;
            color: #495057;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
            border: 2px dashed #dee2e6;
            min-height: 150px;
        }

        .results-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        .result-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .result-label {
            font-weight: bold;
            color: #495057;
        }

        .result-value {
            font-size: 1.1em;
            color: #28a745;
            margin-left: 10px;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }

        .info-section {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #2196f3;
        }

        .info-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 10px;
        }

        .info-text {
            color: #424242;
            line-height: 1.6;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Analisador de Resson√¢ncia Magn√©tica</h1>
            <p>An√°lise inteligente de imagens m√©dicas usando IA</p>
        </div>

        <div class="main-card">
            <div class="upload-section">
                <h2>üìÅ Upload do Arquivo NIfTI</h2>
                <p>Selecione um arquivo de resson√¢ncia magn√©tica (.nii ou .nii.gz) para an√°lise</p>
                
                <div class="upload-btn-wrapper">
                    <button class="upload-btn">
                        üì§ Escolher Arquivo .nii
                    </button>
                    <input type="file" id="nii-upload" accept=".nii,.nii.gz">
                </div>
                
                <div class="progress-bar" id="progress-bar" style="display: none;">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>

            <div class="status-section">
                <div class="status-text" id="status">
                    ü§ñ Carregando modelo de IA...
                </div>
            </div>

            <div class="results-section" id="results-section">
                <div class="results-title">üìä Resultados da An√°lise</div>
                <div id="results-content">
                    <p style="text-align: center; color: #6c757d; font-style: italic;">
                        Os resultados da an√°lise aparecer√£o aqui ap√≥s o upload do arquivo.
                    </p>
                </div>
            </div>
        </div>

        <div class="info-section">
            <div class="info-title">‚ÑπÔ∏è Informa√ß√µes Importantes</div>
            <div class="info-text">
                <p><strong>Formatos aceitos:</strong> .nii, .nii.gz (formato NIfTI)</p>
                <p><strong>Dimens√µes esperadas:</strong> O modelo foi treinado para imagens de 128x128 pixels</p>
                <p><strong>Processamento:</strong> A an√°lise √© realizada localmente no seu navegador</p>
                <p><strong>Privacidade:</strong> Seus dados n√£o s√£o enviados para nenhum servidor externo</p>
            </div>
        </div>
    </div>

    <script>
        // Elementos da interface
        const inputArquivo = document.getElementById('nii-upload');
        const statusDisplay = document.getElementById('status');
        const resultsContent = document.getElementById('results-content');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');

        // Vari√°veis globais
        let modelo = null;
        let modeloCarregado = false;

        // Fun√ß√£o para atualizar o status
        function atualizarStatus(mensagem, tipo = 'info', mostrarLoading = false) {
            const loading = mostrarLoading ? '<span class="loading"></span>' : '';
            statusDisplay.innerHTML = loading + mensagem;
            
            // Remove classes anteriores
            statusDisplay.parentElement.classList.remove('error', 'success');
            
            // Adiciona nova classe se especificada
            if (tipo === 'error') {
                statusDisplay.parentElement.classList.add('error');
            } else if (tipo === 'success') {
                statusDisplay.parentElement.classList.add('success');
            }
        }

        // Fun√ß√£o para atualizar a barra de progresso
        function atualizarProgresso(porcentagem) {
            if (porcentagem > 0) {
                progressBar.style.display = 'block';
                progressFill.style.width = porcentagem + '%';
            } else {
                progressBar.style.display = 'none';
            }
        }

        // Fun√ß√£o para carregar o modelo
        async function carregarModelo() {
            try {
                atualizarStatus('ü§ñ Carregando modelo de IA...', 'info', true);
                atualizarProgresso(20);
                
                // Carrega o modelo do TensorFlow.js
                modelo = await tf.loadLayersModel('./modelo_web/model.json');
                
                atualizarProgresso(100);
                atualizarStatus('‚úÖ Modelo carregado com sucesso! Selecione um arquivo .nii para an√°lise.', 'success');
                modeloCarregado = true;
                
                console.log('Modelo carregado:', modelo);
                console.log('Formato de entrada esperado:', modelo.inputs[0].shape);
                console.log('Formato de sa√≠da:', modelo.outputs[0].shape);
                
                setTimeout(() => atualizarProgresso(0), 2000);
                
            } catch (error) {
                console.error('Erro ao carregar modelo:', error);
                atualizarStatus('‚ùå Erro ao carregar o modelo. Verifique se os arquivos est√£o no local correto.', 'error');
                atualizarProgresso(0);
            }
        }

        // Fun√ß√£o para processar arquivo NIfTI
        async function processarArquivoNifti(arquivo) {
            try {
                atualizarStatus('üìñ Lendo arquivo NIfTI...', 'info', true);
                atualizarProgresso(25);

                // L√™ o arquivo como ArrayBuffer
                const buffer = await arquivo.arrayBuffer();
                
                // Verifica se √© um arquivo .nii.gz (comprimido)
                let dadosBuffer = buffer;
                if (arquivo.name.endsWith('.gz')) {
                    atualizarStatus('üì¶ Descomprimindo arquivo...', 'info', true);
                    dadosBuffer = pako.inflate(new Uint8Array(buffer)).buffer;
                }

                atualizarProgresso(50);

                // Verifica se √© um arquivo NIfTI v√°lido
                if (!nifti.isNIFTI(dadosBuffer)) {
                    throw new Error('O arquivo selecionado n√£o √© um arquivo NIfTI v√°lido.');
                }

                // L√™ o header e os dados da imagem
                const header = nifti.readHeader(dadosBuffer);
                const imagemData = nifti.readImage(header, dadosBuffer);
                
                atualizarStatus('üîÑ Pr√©-processando dados...', 'info', true);
                atualizarProgresso(75);

                console.log('Dimens√µes da imagem:', header.dims);
                console.log('Tipo de dados:', header.datatypeCode);

                // Converte para Float32Array
                const dadosFloat32 = new Float32Array(imagemData);
                
                return {
                    dados: dadosFloat32,
                    header: header,
                    dimensoes: header.dims.slice(1, 4) // Remove a primeira dimens√£o (que √© sempre 0)
                };

            } catch (error) {
                console.error('Erro ao processar arquivo NIfTI:', error);
                throw error;
            }
        }

        // Fun√ß√£o para pr√©-processar os dados para o modelo
        function preprocessarDados(dados, dimensoes) {
            try {
                // O modelo espera entrada de [batch, 128, 128, 2]
                const [altura, largura, profundidade] = dimensoes;
                
                console.log('Dimens√µes originais:', dimensoes);
                
                // Para este exemplo, vamos pegar duas fatias da imagem 3D
                // e redimensionar para 128x128 se necess√°rio
                
                // Calcula o √≠ndice das fatias centrais
                const fatiaMedia1 = Math.floor(profundidade * 0.4);
                const fatiaMedia2 = Math.floor(profundidade * 0.6);
                
                // Extrai as duas fatias
                const fatia1 = new Float32Array(altura * largura);
                const fatia2 = new Float32Array(altura * largura);
                
                for (let i = 0; i < altura; i++) {
                    for (let j = 0; j < largura; j++) {
                        const idx2D = i * largura + j;
                        const idx3D1 = (fatiaMedia1 * altura * largura) + idx2D;
                        const idx3D2 = (fatiaMedia2 * altura * largura) + idx2D;
                        
                        fatia1[idx2D] = dados[idx3D1] || 0;
                        fatia2[idx2D] = dados[idx3D2] || 0;
                    }
                }

                // Cria tensor das duas fatias
                let tensor1 = tf.tensor2d(fatia1, [altura, largura]);
                let tensor2 = tf.tensor2d(fatia2, [altura, largura]);

                // Redimensiona para 128x128 se necess√°rio
                if (altura !== 128 || largura !== 128) {
                    tensor1 = tf.image.resizeBilinear(tensor1.expandDims(2), [128, 128]).squeeze(2);
                    tensor2 = tf.image.resizeBilinear(tensor2.expandDims(2), [128, 128]).squeeze(2);
                }

                // Normaliza os dados (0-1)
                const min1 = tensor1.min();
                const max1 = tensor1.max();
                const min2 = tensor2.min();
                const max2 = tensor2.max();

                tensor1 = tensor1.sub(min1).div(max1.sub(min1).add(1e-8));
                tensor2 = tensor2.sub(min2).div(max2.sub(min2).add(1e-8));

                // Combina as duas fatias em um tensor de 2 canais
                const tensorCombinado = tf.stack([tensor1, tensor2], 2);
                
                // Adiciona dimens√£o de batch
                const tensorFinal = tensorCombinado.expandDims(0);

                console.log('Formato do tensor final:', tensorFinal.shape);

                // Limpa tensors intermedi√°rios
                tensor1.dispose();
                tensor2.dispose();
                tensorCombinado.dispose();
                min1.dispose();
                max1.dispose();
                min2.dispose();
                max2.dispose();

                return tensorFinal;

            } catch (error) {
                console.error('Erro no pr√©-processamento:', error);
                throw error;
            }
        }

        // Fun√ß√£o para fazer a previs√£o
        async function fazerPrevisao(tensorEntrada) {
            try {
                atualizarStatus('üß† Executando an√°lise com IA...', 'info', true);
                atualizarProgresso(90);

                // Faz a previs√£o
                const previsao = modelo.predict(tensorEntrada);
                const resultadoArray = await previsao.data();

                console.log('Resultado da previs√£o:', resultadoArray);
                console.log('Formato da sa√≠da:', previsao.shape);

                // O modelo produz uma segmenta√ß√£o com 4 classes
                // Vamos calcular estat√≠sticas b√°sicas
                const totalPixels = resultadoArray.length / 4; // 4 classes
                const estatisticas = {
                    classe0: 0, // Background
                    classe1: 0, // Necrose
                    classe2: 0, // Edema
                    classe3: 0  // Tumor real√ßado
                };

                // Conta pixels por classe (argmax)
                for (let i = 0; i < totalPixels; i++) {
                    const baseIdx = i * 4;
                    let maxIdx = 0;
                    let maxVal = resultadoArray[baseIdx];
                    
                    for (let j = 1; j < 4; j++) {
                        if (resultadoArray[baseIdx + j] > maxVal) {
                            maxVal = resultadoArray[baseIdx + j];
                            maxIdx = j;
                        }
                    }
                    
                    switch(maxIdx) {
                        case 0: estatisticas.classe0++; break;
                        case 1: estatisticas.classe1++; break;
                        case 2: estatisticas.classe2++; break;
                        case 3: estatisticas.classe3++; break;
                    }
                }

                // Calcula porcentagens
                const porcentagens = {
                    background: (estatisticas.classe0 / totalPixels * 100).toFixed(2),
                    necrose: (estatisticas.classe1 / totalPixels * 100).toFixed(2),
                    edema: (estatisticas.classe2 / totalPixels * 100).toFixed(2),
                    tumorRealcado: (estatisticas.classe3 / totalPixels * 100).toFixed(2)
                };

                // Limpa mem√≥ria
                previsao.dispose();
                tensorEntrada.dispose();

                return porcentagens;

            } catch (error) {
                console.error('Erro na previs√£o:', error);
                throw error;
            }
        }

        // Fun√ß√£o para exibir resultados
        function exibirResultados(resultados) {
            const html = `
                <div class="result-item">
                    <span class="result-label">üîµ Background:</span>
                    <span class="result-value">${resultados.background}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üî¥ Necrose:</span>
                    <span class="result-value">${resultados.necrose}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üü° Edema:</span>
                    <span class="result-value">${resultados.edema}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üü¢ Tumor Real√ßado:</span>
                    <span class="result-value">${resultados.tumorRealcado}%</span>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
                    <small style="color: #1976d2;">
                        <strong>Nota:</strong> Esta √© uma an√°lise automatizada para fins educacionais. 
                        Sempre consulte um profissional m√©dico para diagn√≥sticos precisos.
                    </small>
                </div>
            `;
            
            resultsContent.innerHTML = html;
        }

        // Event listener para upload de arquivo
        inputArquivo.addEventListener('change', async function(evento) {
            if (!modeloCarregado) {
                atualizarStatus('‚è≥ Aguarde o modelo terminar de carregar...', 'error');
                return;
            }

            if (evento.target.files.length === 0) return;

            const arquivo = evento.target.files[0];
            
            try {
                atualizarStatus(`üìÅ Processando: ${arquivo.name}`, 'info', true);
                
                // Processa o arquivo NIfTI
                const dadosProcessados = await processarArquivoNifti(arquivo);
                
                // Pr√©-processa os dados
                const tensorEntrada = preprocessarDados(dadosProcessados.dados, dadosProcessados.dimensoes);
                
                // Faz a previs√£o
                const resultados = await fazerPrevisao(tensorEntrada);
                
                // Exibe os resultados
                exibirResultados(resultados);
                
                atualizarProgresso(100);
                atualizarStatus('‚úÖ An√°lise conclu√≠da com sucesso!', 'success');
                
                setTimeout(() => atualizarProgresso(0), 3000);

            } catch (error) {
                console.error('Erro durante o processamento:', error);
                atualizarStatus(`‚ùå Erro: ${error.message}`, 'error');
                atualizarProgresso(0);
                
                resultsContent.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 20px;">
                        <p><strong>Erro no processamento:</strong></p>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #6c757d;">
                            Verifique se o arquivo √© um NIfTI v√°lido (.nii ou .nii.gz)
                        </p>
                    </div>
                `;
            }
        });

        // Inicia o carregamento do modelo quando a p√°gina carrega
        window.addEventListener('load', carregarModelo);

        // Log de informa√ß√µes do TensorFlow.js
        console.log('TensorFlow.js vers√£o:', tf.version.tfjs);
        console.log('Backend:', tf.getBackend());
    </script>
</body>
</html>

